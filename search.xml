<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Build_HTTP/HTTPS_Proxy]]></title>
      <url>http://yoursite.com/2016/10/05/Build-HTTP-HTTPS-Proxy/</url>
      <content type="html"><![CDATA[<p>本文尝试通过<code>node.js</code>搭建HTTP/HTTPS代理。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">var net = require(&apos;net&apos;);</div><div class="line">var url = require(&apos;url&apos;);</div><div class="line">// console.log(&quot;start server&quot;);</div><div class="line">function request(cReq, cRes) &#123;</div><div class="line">    var u = url.parse(cReq.url);</div><div class="line">    var options = &#123;</div><div class="line">        hostname : u.hostname,</div><div class="line">        port     : u.port || 80,</div><div class="line">        path     : u.path,       </div><div class="line">        method     : cReq.method,</div><div class="line">        headers     : cReq.headers</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    var pReq = http.request(options, function(pRes) &#123;</div><div class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</div><div class="line">        pRes.pipe(cRes);</div><div class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</div><div class="line">        cRes.end();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    cReq.pipe(pReq);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function connect(cReq, cSock) &#123;</div><div class="line">    var u = url.parse(&apos;http://&apos; + cReq.url);</div><div class="line"></div><div class="line">    var pSock = net.connect(u.port, u.hostname, function() &#123;</div><div class="line">        cSock.write(&apos;HTTP/1.1 200 Connection Established\r\n\r\n&apos;);</div><div class="line">        pSock.pipe(cSock);</div><div class="line">    &#125;).on(&apos;error&apos;, function(e) &#123;</div><div class="line">        cSock.end();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    cSock.pipe(pSock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer()</div><div class="line">    .on(&apos;request&apos;, request)</div><div class="line">    .on(&apos;connect&apos;, connect)</div><div class="line">    .listen(8888, &apos;0.0.0.0&apos;);</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="external">HTTP 代理原理及实现（一）</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac多版本Numpy引入问题]]></title>
      <url>http://yoursite.com/2016/09/26/Mac%E5%A4%9A%E7%89%88%E6%9C%ACNumpy%E5%BC%95%E5%85%A5%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>Mac电脑系统本身会维护一个<code>numpy</code>版本，安装新<code>numpy</code>版本之后的导入会因此带来问题。</p>
<a id="more"></a>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我目前使用的MBP版本是<code>OS X EI Capitan (10.11.6)</code>，在终端使用的系统默认安装的<code>python 2.7</code>, 如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[talus@talusMac ~]$ <span class="built_in">which</span> python</div><div class="line">/usr/bin/python</div></pre></td></tr></table></figure></p>
<p>该版本的<code>Mac</code>自己维护了一个版本的<code>numpy</code>，版本为<code>1.8.0rc1</code>, 在<code>python</code>中导入之后显示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[talus@talusMac python]$ python</div><div class="line">Python 2.7.10 (default, Oct 23 2015, 19:19:21)</div><div class="line">[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.5)] on darwin</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import numpy</div><div class="line">&gt;&gt;&gt; numpy.__version__</div><div class="line">&apos;1.8.0rc1&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p><code>numpy 1.8</code>的版本比较老，需要手动升级更新一下。使用<code>pip install numpy==1.11.0</code>安装新版本的<code>numpy</code>之后，导入<code>numpy</code>显示的仍然是<code>1.8.0rc1</code>的版本，并未加载新的版本。</p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>首先查看当前<code>python</code>的<code>sys.path</code>选项, 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import sys</div><div class="line">&gt;&gt;&gt; print &quot;\n&quot;.join(sys.path)</div><div class="line"></div><div class="line">/Users/talus/Projects/db_oj/common/lib</div><div class="line">/Users/talus/Projects/db_oj/frontend</div><div class="line">/Users/talus</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/PyObjC</div><div class="line">/Library/Python/2.7/site-packages</div><div class="line">/Library/Python/2.7/site-packages/PIL</div><div class="line">/Users/talus/.pip/repository</div></pre></td></tr></table></figure></p>
<p>其中</p>
<ul>
<li><code>/Users/talus/Projects/db_oj/common/lib</code>和<code>/Users/talus/Projects/db_oj/frontend</code>是自行在<code>PYTHONPATH</code>环境变量中添加的；</li>
<li><code>/Users/talus</code>是当前目录；</li>
<li>中间<code>System</code>目录下的<code>package</code>都是系统默认维护的<code>package</code>列表；</li>
<li><code>/Library/Python/2.7/site-packages</code>是<code>easy_install</code>维护的列表；</li>
<li><code>/Users/talus/.pip/repository</code>是自定义的<code>pip</code>库位置， 刚安装的<code>numpy==1.11.0</code>版本就安装在该目录中。</li>
</ul>
<p>可以看出， Mac系统默认维护的库位置为<code>/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python</code>, 如果进入目录可以看到有默认安装的<code>numpy</code>, <code>matplotlib</code>等。<br>使用<code>easy_install</code>或者<code>pip</code>默认会将packet安装在<code>/Library/Python/2.7/site-packages</code>, 但在更改之后的<code>pip</code>路径为<code>/Users/talus/.pip/repository</code>。</p>
<p>问题的原因就在于<code>python</code>搜索<code>numpy</code>时，Mac默认的库位置早于<code>pip</code>库设定的位置，从而会加载默认版本的<code>numpy</code>，即<code>1.8.0rc1</code>版本的。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>根据之前的分析，解决该问题的思路就是将<code>repository</code>的加载顺序提升到<code>Extras/lib/python</code>之前。</p>
<p>在<code>/Library/Python/2.7/site-packages</code>目录下有默认的<code>easy_install.pth</code>文件，该文件指定了<code>python</code>启动时库的加载顺序。<br>默认代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys; sys.__plen = len(sys.path)</div><div class="line">./numpy-1.11.0-py2.7-macosx-10.11-intel.egg</div><div class="line">import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,&apos;__egginsert&apos;,0); sys.path[p:p]=new;  sys.__egginsert = p+len(new)</div></pre></td></tr></table></figure></p>
<p>只需要将自定义的库文件位置<code>repository</code>添加到加载其他库文件之前即可，添加完的文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import sys; sys.__plen = len(sys.path)</div><div class="line">./numpy-1.11.0-py2.7-macosx-10.11-intel.egg</div><div class="line">/Users/talus/.pip/repository</div><div class="line">import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,&apos;__egginsert&apos;,0); sys.path[p:p]=new;  sys.__egginsert = p+len(new)</div></pre></td></tr></table></figure></p>
<p>之后开启新的终端执行显示<code>sys.path</code>之后可以看到已经将<code>/Users/talus/.pip/repository</code>放置在其他路径之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/Users/talus/.pip/repository</div><div class="line">/Users/talus/Projects/db_oj/common/lib</div><div class="line">/Users/talus/Projects/db_oj/frontend</div><div class="line">/Users/talus</div><div class="line">/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>从终端执行<code>import numpy</code>之后，也发现加载了新安装的<code>numpy</code>版本。</p>
<h4 id="未设置pip默认目录的解决办法"><a href="#未设置pip默认目录的解决办法" class="headerlink" title="未设置pip默认目录的解决办法"></a>未设置pip默认目录的解决办法</h4><p>未设置<code>pip</code>默认目录时，安装的<code>numpy</code>会被安装到<code>/Library/Python/2.7/site-packages</code>。 此时只需要在<code>easy_install.pth</code>中将当前的<code>numpy</code>egg路径添加到加载系统文件之前即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import sys; sys.__plen = len(sys.path)</div><div class="line">/Users/talus/.pip/repository</div><div class="line">./simplejson-3.8.2-py2.7-macosx-10.11-intel.egg</div><div class="line">./numpy-1.11.1-py2.7-macosx-10.11-intel.egg</div><div class="line">import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,&apos;__egginsert&apos;,0); sys.path[p:p]=new;  sys.__egginsert = p+len(new)</div></pre></td></tr></table></figure></p>
<p>如果使用<code>easy_install</code>安装<code>numpy</code>，不需要手动添加该条路径，默认会添加该条路径。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/18025510/multiple-numpy-version-on-mac-os-x" target="_blank" rel="external">multiple numpy version on Mac OS X</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[npm配置文件]]></title>
      <url>http://yoursite.com/2016/09/25/npm%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p><code>npm</code>是<code>node.js</code>下默认的包管理器, <code>npm</code>的配置也是基于文件设置的。</p>
<a id="more"></a>
<h3 id="安装nmp"><a href="#安装nmp" class="headerlink" title="安装nmp"></a>安装nmp</h3><p>依照官方教程<a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" rel="external">installing-node</a>即可。</p>
<h3 id="npm配置"><a href="#npm配置" class="headerlink" title="npm配置"></a>npm配置</h3><p><code>npm</code>配置采用<code>命令行+文件</code>的配置方式。</p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p><code>npm</code>的配置命令为<code>npm config [set/get] [key]</code>, 其中<code>get</code>是获取当前配置信息，<code>set</code>是设置当前配置， <code>key</code>为配置项的名字。</p>
<p>如查看使用如下的命令返回当前的npm源地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config get registry</div></pre></td></tr></table></figure></p>
<p>使用如下的命令设置新的npm源地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set registry https://registry.npm.taobao.org/</div></pre></td></tr></table></figure></p>
<p>其他配置命令</p>
<ul>
<li><code>npm config list</code>: 显示当前所有的配置</li>
<li><code>npm config edit</code>：编辑全局配置</li>
<li><code>npm config delete key</code>: 编辑key对应的配置项</li>
</ul>
<h4 id="文件配置方式"><a href="#文件配置方式" class="headerlink" title="文件配置方式"></a>文件配置方式</h4><p><code>npm</code>默认会读取当前用户<code>home</code>目录下的<code>.npmrc</code>文件作为用户自定义的设置信息，如果试验一下使用命令行更改设置的命令，那么也会发现在<code>.npmrc</code>中会相应地做出变化。<br><code>.npmrc</code>文件的格式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">key=value</div></pre></td></tr></table></figure></p>
<p>其中<code>key</code>为配置项名称，<code>value</code>为配置项内容，如配置源为国内的淘宝源，文件中的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">registry=https://registry.npm.taobao.org/</div></pre></td></tr></table></figure></p>
<p>因此，自定义<code>npm</code>的相关配置可以采用<code>npm config</code>的方式, 或者直接在<code>.npmrc</code>文件中添加相应的内容即可。</p>
<h3 id="常见的配置"><a href="#常见的配置" class="headerlink" title="常见的配置"></a>常见的配置</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程编程-线程基本操作]]></title>
      <url>http://yoursite.com/2016/06/28/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>从本节开始，将通过一系列的文章博客介绍Java并发编程的相关内容。此处为第一篇，介绍Java多线程中线程的基本管理，包括线程创建，sleep以及中断等。<br><a id="more"></a></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><code>Java</code>语言中采用的单线程模型，也就是在程序中不手动唤起新的线程时，默认就采用单个线程运行任务。需要注意的是，虽然只是采用单线程运行任务，但并不代表只启动一个线程，比如还会有线程负责垃圾回收等。<br>在执行<code>Java</code>命令时，操作系统默认会启动一个<code>JVM</code>进程，进程会同时创建几个线程，其中的主线程负责任务运行。</p>
<p>线程共有如下的6种状态:</p>
<ul>
<li>New(新创建)</li>
<li>Runnable(可运行的)</li>
<li>Blocked (被阻塞的)</li>
<li>Waiting (等待中的)</li>
<li>Timed Waiting (计时等待的)</li>
<li>Terminated (终止的)</li>
</ul>
<p>各个状态之间的线程转移和切换方式如下图。<br><img src="/2016/06/28/Java多线程编程-创建线程/thread-state-diagram.png" alt="Thread State Diagram" title="Thread State Diagram"></p>
<h3 id="定义与创建线程"><a href="#定义与创建线程" class="headerlink" title="定义与创建线程"></a>定义与创建线程</h3><h4 id="定义线程"><a href="#定义线程" class="headerlink" title="定义线程"></a>定义线程</h4><p>在<code>Java</code>中，创建新的线程可以有两种方式，实现<code>Runnable</code>接口或者继承<code>Thread</code>类.</p>
<p>实现<code>Runnable</code>接口需要重写<code>run</code>方法，<code>run</code>方法定义了线程需要执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承自<code>Thread</code>类也需要重写<code>run</code>方法，定义线程执行的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用两种方式都能创建新的线程，由于<code>Java</code>的单继承特性，如果需要从多个类进行继承，那么只能使用<code>Runnable</code>接口实现新的线程。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>声明一个新的线程对象即创建了一个新的线程, 创建完线程之后，线程的状态为<code>New</code>, 表示是新创建的, 还需要进行初始化才能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyThread thread = <span class="keyword">new</span> MyThread()</div></pre></td></tr></table></figure>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>启动线程时需要先创建该线程的一个实例，然后调用线程的<code>start</code>方法，系统会自动创建一个新的线程并调用该线程的<code>run</code>方法执行。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line">        thread.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>特别需要强调的是</strong>, 启动新的线程必须调用<code>start</code>方法, 而不是<code>run</code>方法。直接调用<code>run</code>方法只会执行当前主线程的任务，而不是启动新的线程，与普通的方法调用没有区别。</p>
<p>一旦调用<code>start</code>方法，线程的状态就变为<code>runnable</code>状态，表示线程可以运行，但是线程是否能运行取决于操作系统是否提供给足够的资源。目前操作系统的线程调度方式分为<code>抢占式线程调度</code>和<code>协作式线程调度</code>，前者是当线程使用完时间片之后，就会被剥夺控制权；后者是只有线程主动放弃控制权时，才会失去控制权。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><p>当线程处于<code>被阻塞</code>或者<code>等待</code>状态时，线程处于不活动状态，此时处于消耗资源最少的状态。</p>
<ul>
<li>当线程试图获取一个资源的锁对象时，而该锁被其他线程持有时，线程将进入<code>阻塞状态</code>。当其他对象释放了该锁，并且线程调度器将控制权交给该线程的时候，线程才会继续运行，变成<code>非阻塞</code>状态。</li>
<li>当线程等待另外一个线程通知调度器状态时, 线程进入<code>等待状态</code>。在调用<code>Thread.wait</code>或者<code>Thread.join</code>方法之后，线程进入等待状态，将会释放线程所占有的锁，并交出CPU执行控制权。</li>
<li>当调用<code>wait</code>方法或者<code>join</code>方法以及<code>sleep</code>方法指定超时时间时，线程进入<code>计时等待</code>状态，该状态一直保持到计时结束或者调度器主动发送通知调度。</li>
</ul>
<h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h4><p><code>sleep</code>方法的调用方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sleep(<span class="keyword">long</span> millis)</div><div class="line">sleep(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)</div><div class="line"></div><div class="line"><span class="comment">//第一个参数指定的是毫秒，第二个参数指定的是纳秒</span></div></pre></td></tr></table></figure></p>
<p><code>sleep</code>方法使得线程睡眠，交出CPU控制权，但是并不释放锁。只能睡眠时间结束之后，才能回到<code>Runnable</code>状态。</p>
<h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><p><code>yield</code>方法与<code>sleep</code>方法类似，是使得CPU交出控制权并执行其他任务，同样也不会释放锁。与<code>sleep</code>方法不同的是，<code>yield</code>方法不能控制具体交出CPU的时间。</p>
<h4 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h4><p>调用<code>wait</code>方法会让进程进入到阻塞状态, 并且释放进程占用的锁，交出CPU的执行权。</p>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p><code>join</code>方法将指定的线程加入到当前线程中执行，直到该线程执行完或者执行一段时间之后再回到调用线程继续执行，<code>join</code>方法的三个版本。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">join()</div><div class="line">join(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></div><div class="line">join(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></div></pre></td></tr></table></figure></p>
<p>调用<code>join</code>方法实则是调用了<code>wait</code>方法，因此<code>join</code>方法也使得进程进入到阻塞状态。</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>调用<code>interrupt</code>方法可以使得线程进入到中断状态。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令-losf]]></title>
      <url>http://yoursite.com/2016/05/24/Linux%E5%91%BD%E4%BB%A4-losf/</url>
      <content type="html"><![CDATA[<p>lsof(list open files)是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p>
<a id="more"></a>
<h3 id="命令使用方式"><a href="#命令使用方式" class="headerlink" title="命令使用方式"></a>命令使用方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof [options] [filename]</div></pre></td></tr></table></figure>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">COMMAND     PID  USER   FD     TYPE             DEVICE  SIZE/OFF     NODE NAME</div><div class="line">loginwind    89 talus  cwd      DIR                1,4      1122        2 /</div><div class="line">loginwind    89 talus  txt      REG                1,4    840176   351678 /System/Library/CoreServices/loginwindow.app/Contents/MacOS/loginwindow</div><div class="line">loginwind    89 talus  txt      REG                1,4      1623    42437 /System/Library/PrivateFrameworks/LoginUIKit.framework/Versions/A/Resources/keyboard.pdf</div><div class="line">loginwind    89 talus  txt      REG                1,4     50744 24773259 /private/var/folders/dj/pv392n3x6w7g5022jqc3lzd80000gn/C/mds/mdsDirectory.db</div><div class="line">loginwind    89 talus  txt      REG                1,4      1960    20304 /System/Library/ColorSync/Profiles/Generic RGB Profile.icc</div><div class="line">loginwind    89 talus  txt      REG                1,4  24438480    50043 /usr/share/icu/icudt53l.dat</div><div class="line">loginwind    89 talus  txt      REG                1,4    137152   147158 /System/Library/LoginPlugins/DisplayServices.loginPlugin/Contents/MacOS/DisplayServices</div><div class="line">loginwind    89 talus  txt      REG                1,4    109920   146802 /System/Library/LoginPlugins/FSDisconnect.loginPlugin/Contents/MacOS/FSDisconnect</div><div class="line">loginwind    89 talus  txt      REG                1,4   3759122    23132 /System/Library/CoreServices/SystemAppearance.bundle/Contents/Resources/SystemAppearance.car</div></pre></td></tr></table></figure>
<p>输出中各项参数如下:</p>
<ul>
<li><code>command</code>: 显示打开文件的命令</li>
<li><code>PID</code>: 进程号</li>
<li><code>USER</code>: 用户</li>
<li><code>FD</code>: 文件描述符号</li>
</ul>
<h3 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数"></a>选项和参数</h3><h3 id="部分实例"><a href="#部分实例" class="headerlink" title="部分实例"></a>部分实例</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux-部分常用命令总结]]></title>
      <url>http://yoursite.com/2016/05/23/Linux-%E9%83%A8%E5%88%86%E5%86%B7%E9%97%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文总结了部分冷门但是比较有用的<code>Linux</code>命令, 以备查阅。<br><a id="more"></a></p>
<h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><h4 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h4><ul>
<li>用法: <code>apropos keyword</code></li>
<li>用途: 用于查找拼写相类似或者发音相类似的命令，在记不准确命令的情况下可以使用。</li>
</ul>
<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><ul>
<li>用途: 统计指定文件中或标准输出中的words, lines, characters, bytes数目</li>
<li>参数:<ul>
<li><code>-l</code>: lines数目</li>
<li><code>-c</code>: bytes数目</li>
<li><code>-w</code>: words数目</li>
<li><code>-m</code>: characters数目</li>
</ul>
</li>
<li>示例:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat 1.txt | wc -lw</div><div class="line">wc -lw 1.txt</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[g++常用编译选项]]></title>
      <url>http://yoursite.com/2016/05/19/g-%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>本篇博文主要汇总总结<code>g++</code>和<code>gcc</code>编译器常用的编译选项，以备以后查看。<br><a id="more"></a></p>
<h3 id="编译过程选项"><a href="#编译过程选项" class="headerlink" title="编译过程选项"></a>编译过程选项</h3><ul>
<li><code>-E</code>: 将源文件进行预处理，不进行编译和链接，默认输出为终端</li>
<li><code>-S</code>: 将源文件编译生成汇编文件</li>
<li><code>-c</code>: 将源文件编译生成目标文件</li>
<li><code>-o</code>: 将源文件或者目标文件编译生成可执行文件, <code>g++ -o outputname x1.cpp(x.o)</code></li>
<li><code>-Wall</code>: 显示编译过程中所有的警告信息</li>
<li><code>-save-temps</code>: 保存编译过程中生成的所有中间文件</li>
<li><code>-g</code>: 在可执行文件中加入标准调试信息，用于程序调试</li>
<li><code>-On</code>: 编译优化，其中n为优化级别,范围为0-3, <code>O3</code>是最高优化级别</li>
<li><code>-Idir</code>: 将目录<code>dir</code>所在的文件夹加入头文件搜索范围</li>
<li><code>-Ldir</code>: 将目录<code>dir</code>所在的文件加入库文件搜索范围</li>
<li><code>-lname</code>: 链接时使用<code>libname.so</code>的动态库或者<code>libname.a</code>静态库</li>
<li><code>Dname[=var]</code>: 定义宏变量<code>name[=var]</code></li>
</ul>
<h3 id="库文件选项"><a href="#库文件选项" class="headerlink" title="库文件选项"></a>库文件选项</h3><h4 id="静态库文件选项"><a href="#静态库文件选项" class="headerlink" title="静态库文件选项"></a>静态库文件选项</h4><p>生成静态库文件命令<code>ar</code>选项</p>
<ul>
<li><code>-a</code>: 位置移动的指定器, 与<code>-r</code>或者<code>-m</code>一同使用, 文件将会被移动到指定的位置索引之后</li>
<li><code>-b</code>: 位置移动的指定器, 与<code>-r</code>或者<code>-m</code>一同使用, 文件将会被移动到指定的位置索引之前</li>
<li><code>-c</code>: 创建库文件</li>
<li><code>-d</code>: 删除库文件中指定的目标文件</li>
<li><code>-i</code>: 等同于<code>-b</code>选项</li>
<li><code>-m</code>: 在库文件中移动指定的库文件位置，如果<code>-a</code>或者<code>-b</code>指定的话，那么移动库文件到该位置，否则移动到文件末尾</li>
<li><code>-p</code>: 将指定的目标文件输出到标准输出，如果没有指定的话，则输出全部的目标文件</li>
<li><code>-q</code>: 快速生成静态库文件，不管目标文件是否已经包含在库文件中, 比<code>-r</code>要快很多，但是库文件会有冗余</li>
<li><code>-S</code>: 打包静态库时不生成符号表，添加该选项生成的静态库文件无法直接使用</li>
<li><code>-t</code>: 列出库文件中指定的目标文件列表，如果没有指定，则列出所有的目标文件</li>
<li><code>-r</code>: 替换或者在库文件末尾添加目标文件，如果库文件不存在，那么则创建库文件; 如果目标文件已存在，那么则替换成目标文件; 如果目标文件不存在，则添加到文件末尾</li>
<li><code>-u</code>: 更新库文件中的目标文件，与<code>-r</code>选项共用时，只有更改比较新的目标文件才会被添加到库文件中; 与<code>-x</code>选项共用时, 只有比文件中已有的目标文件更新时才会解压</li>
<li><code>-v</code>: 显示打包过程中的输出信息</li>
<li><code>-x</code>: 将库文件中的指定的目标文件解压到当前目录，如果没有指定，则解压所有的目标文件</li>
</ul>
<p>生成静态库文件的方式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ g++ -c x1.cpp x2.cpp ......</div><div class="line">$ ar crv libname.a x1.o x2.o</div></pre></td></tr></table></figure></p>
<p>在编译生成动态库的目标文件时，必须加上选项<code>-fPIC</code>, 表示生成位置无关的目标代码，打包成动态库文件的生成方式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ g++ -c <span class="_">-f</span>PIC x1.cpp x2.cpp</div><div class="line">$ g++ -shared -o libname.so x1.o x2.o</div></pre></td></tr></table></figure></p>
<p>也可以直接从源文件生成动态共享库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ <span class="_">-f</span>PIC -shared -o libname.so x1.cpp x2.cpp</div></pre></td></tr></table></figure></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>在Linux平台指定使用<code>C++</code>标准库执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g++ -std=c++11 input.cxx -o a.out</div><div class="line">g++ -std=gnu++11 input.cxx -o a.out</div></pre></td></tr></table></figure>
</li>
<li><p><code>Mac OS X</code> before Mavericks</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g++ -std=c++11 -stdlib=libc++ input.cxx -o a.out</div><div class="line">g++ -std=gnu++11 -stdlib=libc++ input.cxx -o a.out</div><div class="line">clang++ -std=c++11 -stdlib=libc++ input.cxx -o a.out</div><div class="line">clang++ -std=gnu++11 -stdlib=libc++ input.cxx -o a.out</div></pre></td></tr></table></figure>
</li>
<li><p><code>Mac OS X</code> since Mavericks</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clang++ -std=c++11 input.cxx -o a.out</div><div class="line">clang++ -std=gnu++11 input.cxx -o a.out</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.zhli.net/prog-algo/gcc-commonly-used-flags/" target="_blank" rel="external">GCC 常用编译选项及相关工具</a></li>
<li><a href="http://stackoverflow.com/questions/19774778/when-is-it-necessary-to-use-use-the-flag-stdlib-libstdc" target="_blank" rel="external">When is it necessary to use use the flag -stdlib=libstdc++?</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++编译过程解析]]></title>
      <url>http://yoursite.com/2016/05/18/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本篇文章解析<code>C++</code>的编译过程，并且说明如何编译成静态库，动态库以及动态库的加载过程。<br><a id="more"></a></p>
<h3 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++ 编译过程"></a>C++ 编译过程</h3><p>目前C++的编译过程包括四个阶段，分别为<code>Proprocessing</code>, <code>Compilation</code>, <code>Assembly</code>和<code>Linking</code>四个阶段, 四个阶段对应使用的工具分别是<code>preprocessor</code>, <code>compiler</code>, <code>assembler</code>和<code>linker</code>. 编译的四个阶段如下图所示:<br><img src="http://faculty.cs.niu.edu/~mcmahon/CS241/Images/compile.png" alt="C++ Compile Process"></p>
<p>文章将通过一步一步编译如下的示例文件, 解释编译的过程, 该文件命名为<code>prog.cpp</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; N + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p><code>C++</code>预处理器在预处理阶段，将<code>#include</code>包含的<code>头文件</code>拷贝到源文件中, 然后将文件中<code>#define</code>定义的宏变量替换为其真实值。</p>
<p>为了让<code>C++</code>程序在进行预处理之后我们可以观察到其内容，可以采用<code>g++ -E</code>命令。需要注意的是, 预处理之后的代码根据包含的头文件不同, 可能生成几十到几万行的代码，并且显示在<code>STDOUT</code>中, 为此我们将输出重定向到文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -E prog.cpp &gt; preprocess.txt</div></pre></td></tr></table></figure></p>
<p>打开文件，可以看到生成的代码大部分内容都是包含进来的头文件, 示例程序中的宏变量已经做了替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">......(以上略)</div><div class="line">38111 extern __attribute__ ((__visibility__(&quot;default&quot;))) istream cin;</div><div class="line">38112 extern __attribute__ ((__visibility__(&quot;default&quot;))) ostream cout;</div><div class="line">38113 extern __attribute__ ((__visibility__(&quot;default&quot;))) ostream cerr;</div><div class="line">38114 extern __attribute__ ((__visibility__(&quot;default&quot;))) ostream clog;</div><div class="line">38115 extern __attribute__ ((__visibility__(&quot;default&quot;))) wistream wcin;</div><div class="line">38116 extern __attribute__ ((__visibility__(&quot;default&quot;))) wostream wcout;</div><div class="line">38117 extern __attribute__ ((__visibility__(&quot;default&quot;))) wostream wcerr;</div><div class="line">38118 extern __attribute__ ((__visibility__(&quot;default&quot;))) wostream wclog;</div><div class="line">38119</div><div class="line">38120 &#125; &#125;</div><div class="line">38121 # 2 &quot;prog.cpp&quot; 2</div><div class="line">38122</div><div class="line">38123 using namespace std;</div><div class="line">38124</div><div class="line">38125 int main() &#123;</div><div class="line">38126     cout &lt;&lt; 100 + 1 &lt;&lt; endl;</div><div class="line">38127     cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;</div><div class="line">38128 &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Compiling"><a href="#Compiling" class="headerlink" title="Compiling"></a>Compiling</h4><p>在第二个阶段，<code>C++</code>将生成的临时文件(上一个阶段输出到preprocess.txt的内容)编译成汇编文件。<br>使用<code>g++ -S</code>选项可以让<code>g++</code>在编译到汇编阶段停止, 默认情况下会生成与源代码文件同名的<code>.s</code>汇编文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -S prog.cpp</div></pre></td></tr></table></figure></p>
<p>打开<code>prog.s</code>文件, 可以看到是一系列的汇编代码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(以上略)</div><div class="line">1070 Ltmp66:</div><div class="line">1071     .cfi_offset %rbp, -16</div><div class="line">1072     movq    %rsp, %rbp</div><div class="line">1073 Ltmp67:</div><div class="line">1074     .cfi_def_cfa_register %rbp</div><div class="line">1075     movl    $4294967295, %eax       ## imm = 0xFFFFFFFF</div><div class="line">1076     popq    %rbp</div><div class="line">1077     retq</div><div class="line">1078     .cfi_endproc</div><div class="line">1079</div><div class="line">1080     .section    __TEXT,__cstring,cstring_literals</div><div class="line">1081 L_.str:                                 ## @.str</div><div class="line">1082     .asciz  &quot;Hello World!&quot;</div><div class="line">1083</div><div class="line">1084</div><div class="line">1085 .subsections_via_symbols</div></pre></td></tr></table></figure></p>
<h4 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h4><p>第二个阶段生成的<code>.s</code>汇编文件会在第三阶段转换为<code>.o</code>文件, 使用<code>g++ -c</code>选项可以生成<code>.o</code>文件, <code>.o</code>文件是二进制文件，可以使用<code>readelf</code>软件打开查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -c prog.cpp</div></pre></td></tr></table></figure></p>
<h4 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h4><p>链接是编译的最后一个步骤, 编译器将一个或者多个的<code>.o</code>文件与其他的动态库或者静态库进行链接, 最后生成一个可执行文件或者库文件。<br>在第四阶段，生成的<code>.o</code>文件将会与其他依赖的静态库或动态库文件进行链接, 最后生成可执行文件。默认不加任何参数的<code>g++</code>命令会生成名为<code>a.out</code>或<code>a.exe</code>的可执行文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ prog.cpp</div></pre></td></tr></table></figure></p>
<h3 id="C-动态库和静态库"><a href="#C-动态库和静态库" class="headerlink" title="C++动态库和静态库"></a>C++动态库和静态库</h3><p>在编译的第四个阶段，编译器将生成的<code>Object</code>文件与库文件链接成为可执行文件，根据链接阶段如何将库文件链接成可执行的程序。库文件分为静态链接方式和动态链接方式。</p>
<ul>
<li>静态链接方式：对应的库为静态库，链接时将生成的<code>Object</code>文件与库一起打包生成可执行文件中</li>
<li>动态链接方式：对应的库为动态库，链接时并没有被编译进可执行文件中，在程序执行到相关的函数时才从动态库中调用。</li>
</ul>
<p>静态库的名字一般为<code>libxxx.a</code>(Unix), <code>libxxx.lib</code>(Windows), 可以视为是一组<code>Object</code>文件的集合。静态库的优点为:</p>
<ul>
<li>运行时不再依赖编的函数库;</li>
<li>运行时加载速度比较快;</li>
</ul>
<p>缺点也是显而易见的:</p>
<ul>
<li>浪费空间，每个程序都单独打包静态库，那么N个程序实际上只需要一份静态库，其他的空间都被浪费掉了。</li>
<li>更新软件困难，一旦静态库需要进行改动，那么整个程序都需要重新编译和打包，对于游戏或者大型软件是不可接受的。</li>
</ul>
<p>动态库的名字一般为<code>libxxx.so</code>(Unix), <code>libxxx.dll</code>(Windows)。其优缺点与静态库相反, 动态库可以节省大量的空间，动态库只需要在内存中加载一次，其余的程序就可以共用这一静态库。其次，使用动态库的程序更新也更加方便，保持接口不变的情况下，只需要替换相应的动态库文件即可，不需要对整个软件包进行重新编译。其缺点就是在加载过程略慢。</p>
<h4 id="库文件示例文件"><a href="#库文件示例文件" class="headerlink" title="库文件示例文件"></a>库文件示例文件</h4><p>以<a href="https://msdn.microsoft.com/en-us/library/ms235627.aspx#BKMK_CreateLibProject" target="_blank" rel="external">Microsoft Static Library</a>的<code>MathFuncsLib</code>为例，在Linux下打包静态库和动态库。</p>
<p><code>MathFuncsLib.h</code>文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MathFuncs&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Subtract</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Divide</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>MathFuncsLib.cpp</code>文件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFuncsLib.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">double</span> MathFuncs::Add(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">double</span> MathFuncs::Subtract(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">double</span> MathFuncs::Multiply(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</div><div class="line">    <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">double</span> MathFuncs::Divide(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</div><div class="line">    <span class="keyword">return</span> a / b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ExecMathFuncsLib.cpp</code>文件, 调用库文件的测试代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFuncsLib.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> a = <span class="number">7.4</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">99</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt;</div><div class="line">        MathFuncs::Add(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a - b = "</span> &lt;&lt;</div><div class="line">        MathFuncs::Subtract(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a * b = "</span> &lt;&lt;</div><div class="line">        MathFuncs::Multiply(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a / b = "</span> &lt;&lt;</div><div class="line">        MathFuncs::Divide(a, b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Linux下生成静态库"><a href="#Linux下生成静态库" class="headerlink" title="Linux下生成静态库"></a>Linux下生成静态库</h4><p>在<code>Linux</code>下生成静态库使用的是<code>ar</code>命令，<code>ar</code>命令读入一个目标文件, 然后将其打包为<code>.a</code>静态库文件。</p>
<p>首先生成<code>Object</code>文件, 之后使用<code>ar</code>命令打包成为静态库文件.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ g++ -c MathFuncsLib.cpp</div><div class="line">$ ar -crv libmathfuncs.a MathFuncsLib.o</div></pre></td></tr></table></figure></p>
<p>可以看到在工程目录下已经生成了静态库文件<code>libmathfuncs.a</code>。在使用<code>ExecMathFuncsLib.cpp</code>示例文件时，编译时指定参数静态库的路径和静态库名，静态库名不需要使用<code>lib</code>前缀和<code>.a</code>后缀，系统会自动寻找库名相匹配的文件，搜索路径在当前例子中就是当前目录<code>.</code>。<code>-L</code>参数指定搜索路径, <code>-l</code>参数指定动态库或静态库的名称。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ ExecMathFuncsLib.cpp -L. -lmathfuncs</div></pre></td></tr></table></figure></p>
<p>在编译完测试文件之后, 已经生成了可执行文件<code>a.out</code>.</p>
<h4 id="使用Linux静态库"><a href="#使用Linux静态库" class="headerlink" title="使用Linux静态库"></a>使用Linux静态库</h4><p>在<code>Linux</code>下生成动态库使用<code>g++ -shared</code>命令即可，读入一个目标文件，然后将其编译为动态文件<code>.so</code>文件。</p>
<p>首先生成目标文件，之后使用<code>g++</code>命令打包成为动态库文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ g++ -c MathFuncsLib.cpp</div><div class="line">$ g++ -shared -o libmathfuncs.so MathFuncsLib.o</div></pre></td></tr></table></figure></p>
<p>执行完该命令之后，可以看到在目录下已经生成了动态库文件<code>libmathfuncs.so</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ ExecMathFuncsLib.cpp -L. -lmathfuncs</div></pre></td></tr></table></figure>
<h4 id="动态库加载方式"><a href="#动态库加载方式" class="headerlink" title="动态库加载方式"></a>动态库加载方式</h4><p>由于该例子生成的动态库和测试样例在同一个文件目录下, 所以直接编译运行即可。现在尝试将<code>libmathfuncs.so</code>移动到<code>lib</code>子目录下, 此时使用如下的命令编译运行测试文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ g++ ExecMathFuncsLib.cpp -L./lib -lmathfuncs</div><div class="line">$ ./a.out</div></pre></td></tr></table></figure></p>
<p>发现运行该程序时会报错显示动态库加载不成功，错误信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dyld: Library not loaded: libmathfuncs.so</div><div class="line">  Referenced from: xxxxx/a.out</div><div class="line">  Reason: image not found</div><div class="line">Trace/BPT trap: 5</div></pre></td></tr></table></figure></p>
<p>其中<code>dyld</code>是<code>dynamic loader</code>的缩写，<code>dyld</code>的主要功能是加载动态共享库，在加载动态库时，<code>dyld</code>会依次按照如下的顺序加载:</p>
<ol>
<li>环境变量<code>LD_LIBRARY_PATH</code>指定的路径</li>
<li><code>/etc/ld.so.cache</code>文件中指定的路径</li>
<li><code>/lib</code>目录</li>
<li><code>/usr/lib</code>目录</li>
</ol>
<p>因此如果想让程序找到动态库, 有如下的三种方式可以实现:</p>
<ol>
<li><p>将动态库路径加到<code>LD_LIBRARY_PATH</code>中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:you_path</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>/etc/ld.so.conf</code>文件中添加路径，并且执行<code>ldconfig</code>命令重新构建<code>/etc/ld.so.cache</code>文件。</p>
</li>
<li>将动态库文件复制到<code>/lib</code>或者<code>/usr/lib</code>中。</li>
</ol>
<p>通常情况下，第一种方式是不建议在生产环境中使用的, 由于<code>LD_LIBRARY_PATH</code>是全局的变量, 很多程序都依赖于该变量会使得一旦<code>LD_LIBRARY_PATH</code>配置错误就会影响大量的程序。通常, <code>LD_LIBRARY_PATH</code>变量主要用来临时配置动态库路径或者临时测试使用。另外一种说法是第二种方式与第一种方式是可能会产生同样的问题，也不被建议使用。</p>
<p>规范建议的使用方式是通过<code>g++ -rpath=your_path</code>参数指定运行环境, 而使用<code>-Lyour_path</code>指定链接时的环境,这种做法会减少对其他程序的影响。<br>示例程序编译运行的建议做法为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ ExecMathFuncsLib.cpp -L./lib -lmathfuncs -rpath=./lib</div></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html" target="_blank" rel="external">The C++ compilation process</a></li>
<li><a href="http://stackoverflow.com/questions/6264249/how-does-the-compilation-linking-process-work" target="_blank" rel="external">How does the compilation/linking process work?</a></li>
<li><a href="http://www.tenouk.com/ModuleW.html" target="_blank" rel="external">COMPILER, ASSEMBLER, LINKER AND LOADER: A BRIEF STORY</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms235627.aspx#BKMK_CreateLibProject" target="_blank" rel="external">Walkthrough: Creating and Using a Static Library (C++)</a></li>
<li><a href="http://www.ituring.com.cn/article/22101" target="_blank" rel="external">Why LD_LIBRARY_PATH is bad</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[只用位运算实现两个整数大小比较]]></title>
      <url>http://yoursite.com/2016/04/26/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<p>据说是某软的面试题, 只用位运算，不用四则运算以及比较运算符比较两个无符号整数的大小, 时间复杂度限制在O(logL)之内。</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有两个<code>unsigned int32</code>的变量<code>a</code>和<code>b</code>, <code>a</code>^<code>b</code>的结果就是<code>a</code>和<code>b</code>中相同的二进制位变为0,相异的二进制位变为1。其结果记为<code>c</code>,<code>c</code>的结果二进制形式可以表示为<code>0...01xxxxxx</code>, 从最高位开始数的第一个<code>1</code>就是<code>a</code>和<code>b</code>之间最高位置不同的数字。接下的工作其实只需要确定<code>a</code>中这一位是<code>0</code>还是<code>1</code>, 如果是<code>0</code>, 那么表示<code>a &lt; b</code>; 反之<code>a &gt; b</code>。提取出最高的位的方法可以使用<code>a</code>与<code>0...01...0</code>做交集，如果得到的值为<code>0</code>, 那么<code>a</code>原来位置上就是<code>0</code>, 反之就是<code>1</code>;</p>
<p>下面这一步是比较巧妙的一步, 如何获得<code>0...01...0</code>，可以使用如下的方法。假设<code>d</code>的二进制表示为<code>0...01...1</code>, 即一部分全0连接一部分全1, 那么<code>d ^= d &gt;&gt; 1</code>就可以得到<code>0...01...0</code>。 下面的问题就是如何得到<code>0...01...1</code>, 可以观察到<code>0...01xxxxxx</code>, 中最高位为<code>1</code>，那么计算<code>c |= c &gt;&gt; 1</code>就可以将最高位的下一位变为<code>1</code>。同理，将此时计算<code>c |= c &gt;&gt; 2</code>就可以将最高位的<code>11</code>复制为<code>1111</code>, 依此类推，就会将后面的<code>xxxx</code>全部替换为<code>1111....</code>。</p>
<h3 id="C-代码-来源于夏洋"><a href="#C-代码-来源于夏洋" class="headerlink" title="C++ 代码(来源于夏洋)"></a>C++ 代码(来源于夏洋)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span> </span>&#123;</div><div class="line">  <span class="keyword">uint32_t</span> diff = a ^ b;</div><div class="line">  <span class="keyword">if</span> (!diff) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 001xxxxx -&gt; 00100000</span></div><div class="line">  diff |= diff &gt;&gt; <span class="number">1</span>;</div><div class="line">  diff |= diff &gt;&gt; <span class="number">2</span>;</div><div class="line">  diff |= diff &gt;&gt; <span class="number">4</span>;</div><div class="line">  diff |= diff &gt;&gt; <span class="number">8</span>;</div><div class="line">  diff |= diff &gt;&gt; <span class="number">16</span>;</div><div class="line">  diff ^= diff &gt;&gt; <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> a &amp; diff ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">作者：夏洋</div><div class="line">链接：https:<span class="comment">//www.zhihu.com/question/44356016/answer/97251524</span></div><div class="line">来源：知乎</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.zhihu.com/question/44356016" target="_blank" rel="external">只用位运算实现比较两整数大小，有没有简短优雅的O(1)的解法？</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++泛型算法索引]]></title>
      <url>http://yoursite.com/2016/04/25/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>C++泛型算法除了常用的<code>sort</code>, <code>fill</code>等之外，还有其他的很多的不常用的泛型算法，本篇文章就对<code>C++泛型算法</code>做一个索引列表，以便查询。<br><a id="more"></a></p>
<p><code>&lt;algorithm&gt;</code>头文件定义了一系列函数，这些函数会在一定范围之内的元素(ranges of elements)上进行操作。</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>只读算法只会读取输入范围之内的元素，而不会更改这些元素。</p>
<h4 id="all-of"><a href="#all-of" class="headerlink" title="all_of"></a><a href="http://www.cplusplus.com/reference/algorithm/all_of/" target="_blank" rel="external">all_of</a></h4><p>测试输入范围之内的元素是否都满足条件。</p>
<h4 id="any-of"><a href="#any-of" class="headerlink" title="any_of"></a><a href="http://www.cplusplus.com/reference/algorithm/any_of/" target="_blank" rel="external">any_of</a></h4><p>测试输入范围之内的元素是否至少有一个满足条件。</p>
<h4 id="none-of"><a href="#none-of" class="headerlink" title="none_of"></a><a href="http://www.cplusplus.com/reference/algorithm/none_of/" target="_blank" rel="external">none_of</a></h4><p>测试输入范围之内的元素是全部不满足条件。</p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a><a href="http://www.cplusplus.com/reference/algorithm/for_each/" target="_blank" rel="external">for_each</a></h4><p>对输入范围之内的元素执行<code>function</code>定义的操作，如果给定的迭代器不是<code>const_iterator</code>, 那么该函数可能会改变元素的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Function&gt;</div><div class="line">   <span class="function">Function <span class="title">for_each</span> <span class="params">(InputIterator first, InputIterator last, Function fn)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a><a href="http://www.cplusplus.com/reference/algorithm/find/" target="_blank" rel="external">find</a></h4><p>在输入范围之内寻找是否存在满足要求的第一个元素，返回类型为迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</div><div class="line">   <span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; val)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a><a href="http://www.cplusplus.com/reference/algorithm/find_if/" target="_blank" rel="external">find_if</a></h4><p>在输入范围之内寻找满足指定条件的第一个元素，返回类型为迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> UnaryPredicate&gt;</div><div class="line">   <span class="function">InputIterator <span class="title">find_if</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="find-if-not"><a href="#find-if-not" class="headerlink" title="find_if_not"></a><a href="http://www.cplusplus.com/reference/algorithm/find_if_not/" target="_blank" rel="external">find_if_not</a></h4><p>在输入范围之内寻找不满足满足指定条件的第一个元素，返回类型为迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> UnaryPredicate&gt;</div><div class="line">   <span class="function">InputIterator <span class="title">find_if_not</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a><a href="http://www.cplusplus.com/reference/algorithm/find_end/" target="_blank" rel="external">find_end</a></h4><p>在<code>first1</code>和<code>last1</code>指定的区间内寻找最后一次出现的与<code>first2</code>和<code>last2</code>完全匹配的区间，并且返回区间第一个元素所在的位置。<code>pred</code>表示判断两个元素是否匹配的函数，缺省条件下使用<code>==</code>运算符比较是否匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">   <span class="function">ForwardIterator1 <span class="title">find_end</span> <span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></div><div class="line">                              ForwardIterator2 first2, ForwardIterator2 last2,</div><div class="line">                              BinaryPredicate pred);</div></pre></td></tr></table></figure>
<p>示例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; haystack (myints,myints+<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="keyword">int</span> needle1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 该函数会返回第6个元素所在的迭代器位置</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line">it = <span class="built_in">std</span>::find_end (haystack.begin(), haystack.end(), needle1, needle1+<span class="number">3</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"needle1 last found at position "</span> &lt;&lt; (it-haystack.begin()) &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"><span class="comment">// 输出结果为: needle1 found at position 5</span></div></pre></td></tr></table></figure></p>
<h4 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a><a href="http://www.cplusplus.com/reference/algorithm/find_first_of/" target="_blank" rel="external">find_first_of</a></h4><p>在<code>first1</code>和<code>last1</code>指定的区间内寻找第一次出现的与<code>first2</code>和<code>last2</code>完全匹配的区间，并且返回区间第一个元素所在的位置。<code>pred</code>表示判断两个元素是否匹配的函数，缺省条件下使用<code>==</code>运算符比较是否匹配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">   <span class="function">ForwardIterator1 <span class="title">find_first_of</span> <span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></div><div class="line">                                   ForwardIterator2 first2, ForwardIterator2 last2,</div><div class="line">                                   BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a><a href="http://www.cplusplus.com/reference/algorithm/adjacent_find/" target="_blank" rel="external">adjacent_find</a></h4><p>在<code>first</code>和<code>last</code>指定的范围内寻找第一次出现的相邻元素之间满足匹配的区间，并且返回区间第一个元素所在的位置。<code>pred</code>表示判断两个元素是否匹配的函数，缺省条件下使用<code>==</code>运算符比较是否匹配。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">   <span class="function">ForwardIterator <span class="title">adjacent_find</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></div><div class="line">                                  BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<p>样例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">5</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">8</span>);</div><div class="line"></div><div class="line">it = <span class="built_in">std</span>::adjacent_find (myvector.begin(), myvector.end());</div><div class="line"><span class="comment">//返回第4个元素所在迭代器，因为第4个元素和第5个元素满足30==30</span></div></pre></td></tr></table></figure></p>
<h4 id="count"><a href="#count" class="headerlink" title="count"></a><a href="http://www.cplusplus.com/reference/algorithm/count/" target="_blank" rel="external">count</a></h4><p>在输入范围之内统计指定元素的个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</div><div class="line">  <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></div><div class="line">    <span class="title">count</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; val)</span>;</div></pre></td></tr></table></figure></p>
<h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a><a href="http://www.cplusplus.com/reference/algorithm/count_if/" target="_blank" rel="external">count_if</a></h4><p>在输入范围之内统计满足指定条件元素的个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> UnaryPredicate&gt;</div><div class="line">  <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></div><div class="line">    <span class="title">count_if</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span>;</div></pre></td></tr></table></figure></p>
<h4 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a><a href="http://www.cplusplus.com/reference/algorithm/mismatch/" target="_blank" rel="external">mismatch</a></h4><p>返回在<code>first1</code>和<code>last1</code>范围内与以<code>first2</code>开始的输入范围中第一个不匹配的元素对，返回类型为<code>pair</code>。pair的一个元素表示在第一个范围内的迭代地址，第二个元素表示在第二个范围内的迭代地址。<br><code>pred</code>参数同上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">  pair&lt;InputIterator1, InputIterator2&gt;</div><div class="line">    mismatch (InputIterator1 first1, InputIterator1 last1,</div><div class="line">              InputIterator2 first2, BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<p>样例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) myvector.push_back (i*<span class="number">10</span>); <span class="comment">// myvector: 10 20 30 40 50</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">80</span>,<span class="number">320</span>,<span class="number">1024</span>&#125;;                <span class="comment">//   myints: 10 20 80 320 1024</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">int</span>*&gt; mypair;</div><div class="line"></div><div class="line"><span class="comment">// using default comparison:</span></div><div class="line">mypair = <span class="built_in">std</span>::mismatch (myvector.begin(), myvector.end(), myints);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First mismatching elements: "</span> &lt;&lt; *mypair.first;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; *mypair.second &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"><span class="comment">//输出: First mismatching elements: 30 and 80</span></div></pre></td></tr></table></figure></p>
<h4 id="equal"><a href="#equal" class="headerlink" title="equal"></a><a href="http://www.cplusplus.com/reference/algorithm/equal/" target="_blank" rel="external">equal</a></h4><p>检查<code>first1</code>和<code>last1</code>指定范围内与<code>first2</code>开始的区间元素是否完全一致, <code>pred</code>参数同上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">equal</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></div><div class="line">              InputIterator2 first2, BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<h4 id="is-permutation"><a href="#is-permutation" class="headerlink" title="is_permutation"></a><a href="http://www.cplusplus.com/reference/algorithm/is_permutation/" target="_blank" rel="external">is_permutation</a></h4><p>检查<code>first1</code>和<code>last1</code>指定范围内与<code>first2</code>开始的区间元素是否是排列的两种形式,即元素一直，顺序可以不一致, <code>pred</code>参数同上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">is_permutation</span> <span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></div><div class="line">                        ForwardIterator2 first2, BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a><a href="http://www.cplusplus.com/reference/algorithm/search/" target="_blank" rel="external">search</a></h4><p>在<code>first1</code>和<code>last1</code>指定的区间内寻找第一次出现的与<code>first2</code>和<code>last2</code>完全匹配的区间，并且返回区间第一个元素所在的位置, <code>pred</code>参数同上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">   <span class="function">ForwardIterator1 <span class="title">search</span> <span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></div><div class="line">                            ForwardIterator2 first2, ForwardIterator2 last2,</div><div class="line">                            BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<h4 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a><a href="http://www.cplusplus.com/reference/algorithm/search_n/" target="_blank" rel="external">search_n</a></h4><p>在<code>first1</code>和<code>last1</code>指定的区间内寻找至少出现<code>count</code>次的<code>val</code>的位置, 并且返回第一次出现的位置,  <code>pred</code>参数同上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">   <span class="function">ForwardIterator <span class="title">search_n</span> <span class="params">( ForwardIterator first, ForwardIterator last,</span></span></div><div class="line">                              Size count, <span class="keyword">const</span> T&amp; val, BinaryPredicate pred);</div></pre></td></tr></table></figure></p>
<p>样例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"></div><div class="line"><span class="comment">// using default comparison:</span></div><div class="line">it = <span class="built_in">std</span>::search_n (myvector.begin(), myvector.end(), <span class="number">2</span>, <span class="number">30</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (it!=myvector.end())</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"two 30s found at position "</span> &lt;&lt; (it-myvector.begin()) &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"match not found\n"</span>;</div><div class="line"><span class="comment">//输出: Two 30s found at position 2</span></div></pre></td></tr></table></figure></p>
<h3 id="写容器算法"><a href="#写容器算法" class="headerlink" title="写容器算法"></a>写容器算法</h3><h3 id="容器分割算法"><a href="#容器分割算法" class="headerlink" title="容器分割算法"></a>容器分割算法</h3><h3 id="容器排序算法"><a href="#容器排序算法" class="headerlink" title="容器排序算法"></a>容器排序算法</h3><h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><h3 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h3><h3 id="堆算法"><a href="#堆算法" class="headerlink" title="堆算法"></a>堆算法</h3><h3 id="最大最小算法"><a href="#最大最小算法" class="headerlink" title="最大最小算法"></a>最大最小算法</h3><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.cplusplus.com/reference/algorithm/" target="_blank" rel="external">C++ Reference</a></li>
<li>C++ Primer</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GNU/Linux压缩解压命令汇总]]></title>
      <url>http://yoursite.com/2016/04/19/GNU-Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p><code>GNU\Linux</code>下压缩和解压命令比较多，文档汇总了常见的的压缩解压命令，以便作为工具随时查阅。<br><a id="more"></a></p>
<h3 id="tar-gz"><a href="#tar-gz" class="headerlink" title=".tar.gz"></a>.tar.gz</h3><ul>
<li>软件包: gzip</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zcvf FileName.tar.gz DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf FileName.tar.gz</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><ul>
<li>软件包: zip</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ zip FileName.zip DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unzip FileName.zip</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h3><ul>
<li>软件包: rar unrar</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rar a FileName.rar DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ rar e FileName.rar</div><div class="line">$ unrar e FileName.rar</div><div class="line"><span class="comment"># 解压缩到指定目录</span></div><div class="line">$ rar x FileName.rar DirName</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tar-bz"><a href="#tar-bz" class="headerlink" title=".tar.bz"></a>.tar.bz</h3><ul>
<li>解压缩:<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar jxvf FileName.tar.bz</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><ul>
<li>软件包: bzip2</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar jcvf FileName.tar.bz2 DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar jxvf FileName.tar.bz2</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tar-xz"><a href="#tar-xz" class="headerlink" title=".tar.xz"></a>.tar.xz</h3><ul>
<li>软件包: xz-utils</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar Jcvf FileName.tar.xz DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar Jxvf FileName.tar.xz</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tgz"><a href="#tgz" class="headerlink" title=".tgz"></a>.tgz</h3><ul>
<li>软件包: gzip</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zcvf FileName.tgz DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf FileName.tgz</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7z"><a href="#7z" class="headerlink" title=".7z"></a>.7z</h3><ul>
<li>软件包: p7zip-full</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ 7z a FileName.7z FileName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ 7z x FileName.7z</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="bz"><a href="#bz" class="headerlink" title=".bz"></a>.bz</h3><ul>
<li>软件包: bzip2</li>
<li>解压缩:<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bzip2 <span class="_">-d</span> FileName.bz</div><div class="line">$ bunzip2 FileName.bz</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><ul>
<li>软件包: bzip2</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bzip2 -z FileName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bzip2 <span class="_">-d</span> FileName.bz2</div><div class="line">$ bunzip2 FileName.bz2</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="xz"><a href="#xz" class="headerlink" title=".xz"></a>.xz</h3><ul>
<li>软件包: xz-utils</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ xz -z FileName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ xz <span class="_">-d</span> FileName.xz</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Z"><a href="#Z" class="headerlink" title=".Z"></a>.Z</h3><ul>
<li>软件包: xz-utils</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ compress FileName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ uncompress FileName.Z</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tar-Z"><a href="#tar-Z" class="headerlink" title=".tar.Z"></a>.tar.Z</h3><ul>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar Zcvf FileName.tar.Z DirName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar Zxvf FileName.tar.Z</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tar-tgz"><a href="#tar-tgz" class="headerlink" title=".tar.tgz"></a>.tar.tgz</h3><ul>
<li>软件包: gzip</li>
<li><p>压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zcvf FileName.tar.tgz FileName</div></pre></td></tr></table></figure>
</li>
<li><p>解压缩:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf FileName.tar.tgz</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LXC在CentOS上的安装和使用]]></title>
      <url>http://yoursite.com/2016/04/19/LXC/</url>
      <content type="html"><![CDATA[<p><code>Linux Container(LXC)</code>是Linux系统上的虚拟化技术，用于建立一个<code>Sandbox</code>，来运行一些不信任的程序。这篇文章是在<code>CentOS</code>系统上安装和使用<code>Linux Container</code>。</p>
<a id="more"></a>
<h2 id="安装LXC"><a href="#安装LXC" class="headerlink" title="安装LXC"></a>安装LXC</h2><p><code>LXC</code>在Ubuntu系统中已经集成为一个Packet, 使用<code>sudo apt-get install lxc</code>就可以安装<code>LXC</code>, 在CentOS需要从源码手动编译安装。</p>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p>在安装之前，首先确保系统更新到最新状态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum update</div></pre></td></tr></table></figure></p>
<p><code>LXC</code>依赖于<code>libpcap</code>和<code>libcgroup</code>库，同时需要使用<code>busybox</code>和<code>utilities</code>工具。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install libcap-devel libcgroup busybox wget bridge-utils</div></pre></td></tr></table></figure></p>
<p><code>LXC</code>从源码编译安装需要使用<code>GCC</code>库以及其他工具，一个一个安装比较费时，在<code>yum</code>中，可以使用安装<code>Development tools</code> 一次性安装好所有源码编译需要的工具。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum groupinstall <span class="string">"Development tools"</span></div></pre></td></tr></table></figure></p>
<h3 id="下载LXC-Container源码"><a href="#下载LXC-Container源码" class="headerlink" title="下载LXC Container源码"></a>下载LXC Container源码</h3><p><a href="https://linuxcontainers.org/lxc/downloads/" target="_blank" rel="external">Linux Container Project</a> 上有LXC的每个版本的代码，可以根据需求选定特定版本的源码，在这里使用的是<code>version 2.0.0</code>版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://linuxcontainers.org/downloads/lxc-2.0.0.tar.gz</div></pre></td></tr></table></figure></p>
<p>另外一种下载源码的方式是通过<code>git</code>, 可以将<code>LXC</code>源码库克隆到本地，然后切换到相应的分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/lxc/lxc</div><div class="line">$ git checkout -b &#123;branch&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>{branch}</code>是需要安装的版本，<code>master</code>是最新的开发版本，<code>stable-2.0.0</code>是<code>2.0.0</code>版本，以此类推。</p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar xvfz lxc-2.0.0.tar.gz</div><div class="line">$ <span class="built_in">cd</span> lxc-2.0.0/</div><div class="line">$ ./configure</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><p>使用<code>lxc-info</code>命令可以测试是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lxc-info --name <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>如果正确配置安装成功，那么将会显示如下的结果, 表示test的<code>namespace</code>没有建立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test doesn&apos;t exist</div></pre></td></tr></table></figure></p>
<p>如果没有正确配置，出现<code>liblxc.so.1</code>找不到的情况，需要手动链接<code>liblxc.so.1</code>。 其中<code>/usr/local/lib/liblxc.so.1.2.0</code>是在<code>version 2.0.0</code>下的库版本, <code>liblxc.so.x.x.x</code>可能会随着<code>LXC</code>变化，需要到<code>/usr/local/lib</code>下确定指定的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ln <span class="_">-s</span> /usr/<span class="built_in">local</span>/lib/liblxc.so.1.2.0 /lib64/liblxc.so.1</div><div class="line">$ ls <span class="_">-l</span> /lib64/liblxc.so.1</div><div class="line">lrwxrwxrwx 1 root root 30 4月  18 12:20 /lib64/liblxc.so.1 -&gt; /usr/<span class="built_in">local</span>/lib/liblxc.so.2.0.0</div></pre></td></tr></table></figure>
<p>再使用<code>lxc-info</code>命令进行测试就可以看到<code>LXC</code>已经正确安装。</p>
<h3 id="查看LXC是否正确配置"><a href="#查看LXC是否正确配置" class="headerlink" title="查看LXC是否正确配置"></a>查看LXC是否正确配置</h3><p>使用<code>lxc-checkconfig</code>命令查看<code>LXC</code>是否已经正确配置。</p>
<p>该命令会输出4个部分：</p>
<blockquote>
<ol>
<li>Namespaces</li>
<li>Control Groups</li>
<li>Misc</li>
<li>Checkpoint/Restore</li>
</ol>
</blockquote>
<p>正确的输出应该如下，四个部分都是<code>enable</code>状态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">Kernel configuration not found at /proc/config.gz; searching...</div><div class="line">Kernel configuration found at /boot/config-3.10.0-327.10.1.el7.x86_64</div><div class="line">--- Namespaces ---</div><div class="line">Namespaces: enabled</div><div class="line">Utsname namespace: enabled</div><div class="line">Ipc namespace: enabled</div><div class="line">Pid namespace: enabled</div><div class="line">User namespace: enabled</div><div class="line">Network namespace: enabled</div><div class="line">Multiple /dev/pts instances: enabled</div><div class="line"></div><div class="line">--- Control groups ---</div><div class="line">Cgroup: enabled</div><div class="line">Cgroup clone_children flag: enabled</div><div class="line">Cgroup device: enabled</div><div class="line">Cgroup <span class="built_in">sched</span>: enabled</div><div class="line">Cgroup cpu account: enabled</div><div class="line">Cgroup memory controller: enabled</div><div class="line">Cgroup cpuset: enabled</div><div class="line"></div><div class="line">--- Misc ---</div><div class="line">Veth pair device: enabled</div><div class="line">Macvlan: enabled</div><div class="line">Vlan: enabled</div><div class="line">Bridges: enabled</div><div class="line">Advanced netfilter: enabled</div><div class="line">CONFIG_NF_NAT_IPV4: enabled</div><div class="line">CONFIG_NF_NAT_IPV6: enabled</div><div class="line">CONFIG_IP_NF_TARGET_MASQUERADE: enabled</div><div class="line">CONFIG_IP6_NF_TARGET_MASQUERADE: enabled</div><div class="line">CONFIG_NETFILTER_XT_TARGET_CHECKSUM: enabled</div><div class="line">FUSE (<span class="keyword">for</span> use with lxcfs): enabled</div><div class="line"></div><div class="line">--- Checkpoint/Restore ---</div><div class="line">checkpoint restore: enabled</div><div class="line">CONFIG_FHANDLE: enabled</div><div class="line">CONFIG_EVENTFD: enabled</div><div class="line">CONFIG_EPOLL: enabled</div><div class="line">CONFIG_UNIX_DIAG: enabled</div><div class="line">CONFIG_INET_DIAG: enabled</div><div class="line">CONFIG_PACKET_DIAG: enabled</div><div class="line">CONFIG_NETLINK_DIAG: enabled</div><div class="line">File capabilities: enabled</div><div class="line"></div><div class="line">Note : Before booting a new kernel, you can check its configuration</div><div class="line">usage : CONFIG=/path/to/config /usr/<span class="built_in">local</span>/bin/lxc-checkconfig</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.thegeekstuff.com/2016/01/install-lxc-linux-containers/" target="_blank" rel="external">How to Install and Setup LXC Linux Containers on CentOS / RHEL / Ubuntu</a></li>
<li><a href="https://linuxcontainers.org/lxc/getting-started/" target="_blank" rel="external">Linux Container Project</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最长上升子序列]]></title>
      <url>http://yoursite.com/2016/04/18/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="LIS介绍"><a href="#LIS介绍" class="headerlink" title="LIS介绍"></a>LIS介绍</h2><p>最长上升子序列(Longest Increasing Subsequence), 简称<code>LIS</code>, 是经典的动态规划题目。给定一个序列，例如<code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>最长的上升子序列为<code>[2, 3, 7, 101]</code>, 长度为<code>4</code>。</p>
<a id="more"></a>
<p><strong>问题</strong>: 给定一个序列<code>a1, a2, a3, ..., an</code>, 找出其中最长的一个子序列<code>s1, s2, s3, ..., sl</code>满足<code>s1 &lt; s2 &lt; s3, ... &lt; sl</code>。<br><strong>分析</strong>: 以<code>dp[i]</code>表示以<code>ai</code>结尾的最长上升子序列，那么<code>dp[i]</code>一定是由<code>aj</code>结尾的子序列加上<code>ai</code>组成的序列，其中<code>0 &lt;= j &lt; i &amp;&amp; aj &lt; ai</code>。<br>因此从<code>j</code>中挑选出最长的子序列，再加上<code>ai</code>,就是以<code>ai</code>结尾的最长上升子序列。在计算完所有的<code>dp[i]</code>之后，从中选出最长的一个上升子序列，就是全局最长的上升子序列。</p>
<h2 id="O-n-2-算法"><a href="#O-n-2-算法" class="headerlink" title="O(n^2)算法"></a>O(n^2)算法</h2><p>动态规划状态转移方程如下, 时间复杂度为<code>O(n^2)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i] = max(dp[j]+1) while 0 &lt;= j &lt; i and nums[i] &gt; nums[j]</div></pre></td></tr></table></figure>
<p><code>C++</code>示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* O(n^2)</div><div class="line">* dp[i] represents the length of LIS ending with nums[i]</div><div class="line">* dp[i] = max(dp[j]+1) while 0 &lt;= j &lt; i and nums[i] &gt; nums[j]</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.size(); i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt; dp[j]+<span class="number">1</span>)</div><div class="line">                dp[i] = dp[j] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (res &lt; dp[i]) res = dp[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="O-nlogn-算法"><a href="#O-nlogn-算法" class="headerlink" title="O(nlogn)算法"></a>O(nlogn)算法</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-33题和81题]]></title>
      <url>http://yoursite.com/2016/04/18/LeetCode-33%E9%A2%98%E5%92%8C81%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>二分查找的灵活运用，对排序数组某一部分进行翻转，然后使用二分查找算法继续以<code>log(N)</code>时间查找元素。<br><a id="more"></a></p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p><strong>33</strong>: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="external">Search in Rotated Sorted Array</a><br><strong>81</strong>: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="external">Search in Rotated Sorted Array II</a></p>
<p><code>Search in Rotated Sorted Array</code>的题目意思如下:</p>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p><strong>81</strong>和<strong>33</strong>的唯一区别是序列中可能有重复元素。</p>
<h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h2><p>这个题目我首先想到的是在LeetCode上有一个与此相关的题目，题号具体记不清楚了，也是排好序的数组在某个地方发生了翻转，然后恢复回来原来的顺序。其实一种笨拙的方法就是先翻转回原来的数组，然后使用<code>binary search</code>进行搜索。</p>
<p>可以这样分析这个题目，在某个地方经过翻转之后的数组，在数组的任何一个位置上，其左右两边一定有一边是有序的。<br>比如在<code>0 1 2 4 5 6 7</code>这个数组中，不论从哪个地方看，两边必定有一边是有序的，传统的二分查找算法，不也是基于这个基础么? 二分查找的过程其实就是不断扔掉<code>target</code>不可能在的一边的过程，判断<code>target</code>不可能在这一边的基础就是至少有一边是有序的。</p>
<p>思路如下：</p>
<ol>
<li>如果<code>nums[mid]</code>等于是<code>target</code>, 那么返回<code>mid</code>即可；</li>
<li>如果<code>nums[l] &lt; nums[mid]</code>, 那么就认为<code>l - mid</code>区间是有序的，如果<code>nums[l] &lt;= target &lt;= nums[mid]</code>,则到左边查找；反之，则到右边查找。</li>
<li>如果<code>nums[l] &gt;= nums[mid]</code>, 那么就认为<code>mid+1 - r</code>区间是有序的，如果<code>nums[mid+1] &lt;= target &lt;= nums[r]</code>,则到右边查找；反之，则到左边查找。</li>
</ol>
<p><strong>需要特别注意的一点</strong>: 在第三种情况中为什么事<code>mid+1</code>, 当<code>l = r-1</code>这种情况出现时, 此时<code>mid = l</code>。那么就是<code>mid+1 - r</code>区间是有序的, <code>mid - r</code>即<code>l - r</code>区间不一定有序。而这种情况不出现时, 由于之前已经判断了<code>nums[mid] != target</code>, 所以使用<code>nums[mid+1]</code>判断并不会有影响。</p>
<p><code>C++</code>示例代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>, mid;</div><div class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</div><div class="line">            mid = (r-l)/<span class="number">2</span> + l;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">if</span> (nums[l] &lt; nums[mid]) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt;= nums[mid]) r = mid - <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (nums[mid+<span class="number">1</span>] &lt;= target &amp;&amp; target &lt;= nums[r]) l = mid + <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a>Search in Rotated Sorted Array II</h2><p>与<code>Search in Rotated Sorted Array</code>相比较，II中只多了一个限制，就是元素有重复。那元素有重复会有什么影响呢？<br>举个例子来说，在<code>1,3,1,1,1</code>这个数组中，第一次二分查找的<code>mid=2</code>,<code>nums[mid]=1</code>, 此时会有<code>nums[l] = nums[mid]</code>。在这个例子中, <code>nums[l] = nums[mid]</code>并不能证明<code>l - mid</code>是有序的，因为中间有<code>3</code>存在，原来数组开始的<code>1</code>环回了，就无法判断此时左边是不是有序的，也不能确定<code>target</code>是不是在<code>l - mid</code>之间。</p>
<p>此时可以确定的是<code>nums[l] = nums[mid] != nums[r]</code>, 所以<code>nums[l]</code>一定不是要找的位置，此时可以将<code>l++</code>, 使得查找区域缩小一个。因此在最坏的情况下，算法的时间复杂度是<code>O(N)</code>. 另外，在这个例子中<code>nums[l] = nums[mid] = nums[r]</code>, 但是却无法判断哪一边是有序的。所在这个题目中，<code>nums[l] = nums[mid]</code>的情况需要特殊处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>, mid;</div><div class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</div><div class="line">            mid = (r-l)/<span class="number">2</span> + l;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span> (nums[l] &lt; nums[mid]) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt;= nums[mid]) r = mid - <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] == nums[mid]) &#123;</div><div class="line">                l++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (nums[mid+<span class="number">1</span>] &lt;= target &amp;&amp; target &lt;= nums[r]) l = mid + <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-116的三种解法]]></title>
      <url>http://yoursite.com/2016/04/18/LeetCode-116%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>LeetCode 116二叉树next指针变换的题目，采用了BFS, Recursion Version和NO-Recursion Version三种方式实现。</p>
<a id="more"></a>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p><strong><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a></strong></p>
<p>Given a binary tree</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TreeLinkNode &#123;</div><div class="line">  TreeLinkNode *left;</div><div class="line">  TreeLinkNode *right;</div><div class="line">  TreeLinkNode *next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="number">1</span></div><div class="line">   /  \</div><div class="line">  <span class="number">2</span>    <span class="number">3</span></div><div class="line"> / \  / \</div><div class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div></pre></td></tr></table></figure>
<p>After calling your function, the tree should look like:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></div><div class="line">   /  \</div><div class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></div><div class="line"> / \  / \</div><div class="line"><span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span> -&gt; <span class="literal">NULL</span></div></pre></td></tr></table></figure>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>看到这道题，我首先想到的竟然是<code>BFS</code>，而不是<code>递归</code>…….显然，在树中需要赋值的每一层节点就是<code>queue</code>里面连续的一段元素，前一个元素的<code>next</code>指针指向后一个元素，每层的最后一个元素指向<code>NULL</code>.这个题目中，给定的<code>tree</code>是满二叉树，所以直接使用计数器来判断队列里面的元素是否是每层的最后一个元素。每层的最后一个元素计数器值分别为<code>1</code>,<code>3</code>,<code>7</code>……,即<code>sum(2^i)</code>, 其中<code>0 &lt;= i &lt; h</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for binary tree with next pointer.</div><div class="line"> * struct TreeLinkNode &#123;</div><div class="line"> *  int val;</div><div class="line"> *  TreeLinkNode *left, *right, *next;</div><div class="line"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/* BFS Version */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, num = <span class="number">1</span>, level = <span class="number">0</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; q;</div><div class="line">        q.push(root);</div><div class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">            TreeLinkNode* cur = q.front();</div><div class="line">            q.pop();</div><div class="line">            cnt++;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(cnt &lt; num) cur-&gt;next = q.front();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                cur-&gt;next = <span class="literal">NULL</span>;</div><div class="line">                num += <span class="number">1</span> &lt;&lt; (++level);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">NULL</span>) q.push(cur-&gt;left);</div><div class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">NULL</span>) q.push(cur-&gt;right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Recursion-Version"><a href="#Recursion-Version" class="headerlink" title="Recursion Version"></a>Recursion Version</h3><p>当然，这道题最简单的思路还是使用递归，对于某个节点，先把左孩子的<code>next</code>指针指向右孩子，然后再处理右孩子的<code>next</code>指针。右孩子有两种情况，一种是右孩子位于最右边了,比如<code>3</code>节点，那么设置<code>next</code>指针为<code>NULL</code>即可；另外一种是不在最右边，比如<code>5</code>节点, 那么就将<code>next</code>指针指向父节点<code>next</code>节点的左孩子，也就是图中的<code>6</code>. 使用code表示就是<code>root-&gt;right-&gt;next = root-&gt;next-&gt;left</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for binary tree with next pointer.</div><div class="line"> * struct TreeLinkNode &#123;</div><div class="line"> *  int val;</div><div class="line"> *  TreeLinkNode *left, *right, *next;</div><div class="line"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     <span class="comment">/* Recursion Version */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root || !root-&gt;left || !root-&gt;right)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        root-&gt;left-&gt;next = root-&gt;right;</div><div class="line">        <span class="keyword">if</span> (root-&gt;next)</div><div class="line">            root-&gt;right-&gt;next = root-&gt;next-&gt;left;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            root-&gt;right-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        connect(root-&gt;left);</div><div class="line">        connect(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="NO-Recursion-Version"><a href="#NO-Recursion-Version" class="headerlink" title="NO-Recursion Version"></a>NO-Recursion Version</h3><p>该问题还可以使用非递归的方式解决，递归是通过调用<code>connect</code>函数一层一层往下计算, 那非递归就可以使用<code>for</code>循环向下延伸，直到最底层。每层的任务就是将下一层节点通过<code>next</code>指针连接起来。连接的思路和递归是相同的，都是先把左孩子的<code>next</code>指针指向右孩子，然后再处理右孩子的<code>next</code>指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for binary tree with next pointer.</div><div class="line"> * struct TreeLinkNode &#123;</div><div class="line"> *  int val;</div><div class="line"> *  TreeLinkNode *left, *right, *next;</div><div class="line"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">       <span class="keyword">for</span> (TreeLinkNode* cur = root; cur; cur = cur-&gt;left) &#123;</div><div class="line">            <span class="keyword">for</span> (TreeLinkNode* next = cur; next; next = next-&gt;next) &#123;</div><div class="line">                <span class="keyword">if</span> (!next-&gt;left) <span class="keyword">break</span>;</div><div class="line">                next-&gt;left-&gt;next = next-&gt;right;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!next-&gt;next)</div><div class="line">                    next-&gt;right-&gt;next = <span class="literal">NULL</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    next-&gt;righ   st-&gt;next = next-&gt;next-&gt;left;</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
